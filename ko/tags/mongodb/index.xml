<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>mongodb on NoizBuster</title>
    <link>https://blog.noizbuster.com/ko/tags/mongodb/</link>
    <description>Recent content in mongodb on NoizBuster</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-kr</language>
    <lastBuildDate>Tue, 01 Nov 2016 13:25:17 +0000</lastBuildDate><atom:link href="https://blog.noizbuster.com/ko/tags/mongodb/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Transaction on MongoDB</title>
      <link>https://blog.noizbuster.com/ko/posts/2016-11-01-132517-mongodb-transaction/</link>
      <pubDate>Tue, 01 Nov 2016 13:25:17 +0000</pubDate>
      
      <guid>https://blog.noizbuster.com/ko/posts/2016-11-01-132517-mongodb-transaction/</guid>
      <description>Introduction 서버 개발을 하는 도중 MongoDB의 서로 다른 Document 에 Atomic 하게 update 가 일어나야 하는 상황이 왔다. 서버는 Node로 되어있고 ORM은 mongoose 를 쓰고있다.
헌데 Mongoose 에는 consistency를 보장하면서 복수의 Document를 업데이트 하는 API가 구현되어있지 않은것으로 보여 이를 해결하고자 한다.
Transaction in MongoDB MongoDB 는 Optimistic concurrency control (OCC) 를 채용하고 있고 내부적으로 write lock을 건다고 한다. 때문에 한개 Collection (=table in RDB) 내 에서의 consistency 는 보장이 된다.</description>
    </item>
    
    <item>
      <title>celery with mongodb</title>
      <link>https://blog.noizbuster.com/ko/posts/2016-01-18-celery-with-mongodb/</link>
      <pubDate>Mon, 18 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>https://blog.noizbuster.com/ko/posts/2016-01-18-celery-with-mongodb/</guid>
      <description>#Celery 와 Mongo DB를 이용한 튜토리얼
참고링크
http://skillachie.com/2013/06/15/intro-celery-and-mongodb/
 install celery
pip install celery
pip install -U &#39;celery[mongodb]&#39;or pip install -U celery-with-mongodb
아래와 같은 형식으로 나중에 브로커를 등록 하면 됨.  BROKER_URL = &amp;#39;mongodb://localhost:27017/database_name&amp;#39; #Where the URL is in the format of: mongodb://userid:password@hostname:port/database_name use test db.createUser( {use: &amp;#34;testUser&amp;#34;, pwd: &amp;#34;test&amp;#34;, roles: [&amp;#34;readWrite&amp;#34;, &amp;#34;dbAdmin&amp;#34;] } ) #다음 명령은 read 권한만 갖고 있는 동일한 사용자를 admin 데이터베이스에 추가하고 testDB2 데이터베이스에 대한 readWrite 권한을 부여한다.</description>
    </item>
    
  </channel>
</rss>
